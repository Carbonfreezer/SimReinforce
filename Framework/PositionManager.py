# -*- coding: utf-8 -*-
"""
Created on Fri Jul 25 11:19:38 2025

@author: Luerig
"""

import pygame as pg
import numpy as np

class PositionManager:
    def __init__(self, pointDictionary):
        '''
        Helper class to manage positions on the basee image. Positions can be detected
        by your paint program with a mouse cursor.

        Parameters
        ----------
        pointDictionary :  
            Disctionary that associates a string (=name of the point) with an array of x,y, coordinates of that point.

        Returns
        -------
        None.

        '''
        
        self.__font = pg.font.SysFont(None, 32)
        self.__pointDictionary = {}
        for key,value in pointDictionary.items():
            self.__pointDictionary[key] = np.array(value)
        
        
        
    def DebugDraw(self, targetSurface):
        '''
        Creates a debug draw with the names of the points over the set postions.

        Parameters
        ----------
        targetSurface :  
            The pygame surface where to draw the debug info to.

        Returns
        -------
        None.

        '''
        for idx, point in self.__pointDictionary.items():
            pg.draw.circle(targetSurface, "Red", point, 5)
            img = self.__font.render(f"{idx}", True, pg.Color(255,255,255))
            self.PaintSprite(targetSurface, img, point)
            
    
    
    def GetPoint(self, index):
        '''
        Asks for a certain point.

        Parameters
        ----------
        index :  
            The name of the point.

        Returns
        -------
         
            Numpy array with position.

        '''
        return self.__pointDictionary[index]
    
    
    @staticmethod
    def PaintSprite(destination, source, point):
        '''
        Helper method to paint a sprite centered at the indicated point (coordinates)

        Parameters
        ----------
        destination :  
            Destination surface where to draw to.
        source :  
            Image (surface) to draw.
        point :  
            Numpy array of point to draw.

        Returns
        -------
        None.

        '''
        rect = source.get_rect()
        targetPoint = point - [rect.width * 0.5, rect.height * 0.5]
        destination.blit(source, targetPoint)
    
    
    
    def GetPath(self, listOfPoints):
        '''
        Returns a path to interpolate position on from later.

        Parameters
        ----------
        listOfPoints :  
            The list of points given as the index names, which with they have been registered.

        Returns
        -------
        totalLength :  
            The total length of the path.
        result :  
            Information on path segments. The return information can be considered
            to be opaque, because it is meant to be used with the following function.

        '''
        result = []
        totalLength = 0.0
        for i in range(len(listOfPoints)-1):
            start = self.__pointDictionary[listOfPoints[i]]
            end = self.__pointDictionary[listOfPoints[i + 1]]
            length = np.linalg.norm(end - start)
            totalLength += length
            entry = {'Start' : start, 'End' : end, 'Length' : length}
            result.append(entry)
        return (totalLength, result)

    @staticmethod
    def GetInterpolatedPosition(path, interPol):
        '''
        Asks for an interpolated position along the path. This is primarily meant for movement animations
        of objects along a certain path.

        Parameters
        ----------
        path :  
            The path  generated by the GetPath Method.
        interPol :  
            The interpolation factor from 0..1 to extract the relative position along the path.

        Returns
        -------
        result:
            The interpolated position along the path as numpy array.

        '''    
        remaining, segments = path
        # Edge case we may get for final image generation.
        if interPol == 1.0:
            return segments[-1]['End']
        remaining *= interPol
        scanning = 0
        while remaining - segments[scanning]['Length'] > 0.0:
            remaining = remaining - segments[scanning]['Length']
            scanning += 1
        
        localF = remaining /  segments[scanning]['Length']
        result = segments[scanning]['Start'] + \
            (segments[scanning]['End'] - segments[scanning]['Start']) * localF
            
        return result
            
        
        
        